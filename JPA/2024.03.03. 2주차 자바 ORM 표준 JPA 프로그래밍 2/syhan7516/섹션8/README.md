## 프록시

- 프록시의 필요성
    - 멤버를 조회할 때 팀도 무조건 함께 조회해야 할까?
    - 예) 멤버와 팀을 함께 사용하는 일 → 함께 가져오면 완전 이득
    - 예) 멤버만 사용하는 일 → 함께 가져오면 완전 손해
- 프록시 기초
    - find vs getReference
        - find : 실제 엔티티 객체 조회
        - getReference : 조회를 미루는 가짜 엔티티 객체 조회
- 프록시 특징
    - 실제 클래스를 상속하여 겉 모양이 동일
        - == 비교가 아닌 instanceof 사용
    - 실제 객체의 참조를 보관하여 해당 객체를 호출하면 실제 객체의 메소드 호출
        - 실제 DB에서 조회한 적이 없기 때문에 초기 값은 NULL
        - 초기화 진행 후 엔티티가 바뀌는 것이 아닌 프록시 객체를 통해서 접근하는 것
- 프록시 객체의 초기화
    - 실제 필요할 때 처음 한 번만 객체의 초기화 진행
    - 초기화 순서
        - 영속성 컨텍스트에 초기화 요청
        - 영속성 컨텍스트 확인
            - 존재 O : 존재한다면 실제 엔티티 반환
            - 존재 X : DB 조회 후 실제 엔티티 생성 & 연결
    - 준영속 상태에서 초기화 진행 시 문제 발생 (LazyInitializationException)
- 프록시 확인
    - 초기화 여부
        - PersistenceUnit.isLoaded(Object entity);
    - 클래스 확인 방법
        - entity.getClass( ).getName( );
    - 강제 초기화
        - org.hibernate.Hibernate.initialize(entity);

## 즉시 로딩과 지연 로딩

- 지연 로딩이란 실제 객체를 사용하는 시점에 DB 조회를 수행
    - fetch = FatchType.LAZY
- 즉시 로딩이란 한 번에 연관된 모든 객체를 DB 조회
    - fetch = FatchType.EAGER
- 멤버와 팀을 함께 자주 사용하는 경우
    - 지연 로딩 → 쿼리 2번 전송 → 즉시 로딩 이득
- 멤버와 팀을 함께 자주 사용하지 않는 경우
    - 지연 로딩 → 필요한 것만 사용 → 지연 로딩 이득
- 주의
    - 가급적 지연 로딩만 사용
        - 즉시 로딩은 예상치 못한 SQL 발생 가능성이 높음
        - 즉시 로딩은 JPQL에서 N+1 문제 발생 (최초 쿼리 1개 + 추가 N개)
    - @ManyToOne, @OneToOne은 기본이 즉시 로딩이므로, LAZY 설정 필요
    - @OneToMany, @ManyToMany는 기본이 지연 로딩
    - → **무조건 지연 로딩으로 설정 후 필요 시 패치 조인으로 변경 !**

## 영속성 전이 : CASCADE

- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들기 원할 경우
    - @OneToMany(…, cascade=CascadeType.설정옵션)
    - 예) Order → Delivery : 주문이 나올 때 배송 정보도 함께 만들기
    - 예) Order → OrderItem : 주문이 나올 때  주문 & 아이템도 함께 만들기
- 주의
    - 연관관계를 매핑하는 것과 아무 관련 X
    - 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공
- 종류
    - ALL : 모두 적용
    - PERSIST : 영속
    - REMOVE : 삭제
    - 사용 조건 1 : 종속, 같은 라이프 사이클
    - 사용 조건 2 : 자식에 대한 소유자가 한 개인 단일 소유권일 때 ! (다른 곳에서 사용 시 불가능)

## 고아 객체

- 부모 엔티티와 연관관계가 끊어진 자식 엔티티
- 주의
    - 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제
        - 참조하는 곳이 하나일 때 사용
        - 특정 엔티티가 개인 소유할 때 사용
        - @OneToOne, @OneToMany 에서 사용
- 특징
    - 개념적으로 활성화인 경우, CasecadeType.REMOVE처럼 동작 (부모 삭제 → 자식 삭제)
    - CasecadeType.ALL+orphanRemoval=true → 부모 엔티티를 통해 자식의 생명 주기 관리 가능