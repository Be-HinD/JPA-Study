## SQL 중심의 개발 문제점

- 배경
    - 객체로 다뤄지는 것이 많아 **객체지향언어** 다수 사용
    - 대부분의 데이터는 **관계형 DB**에 저장하고 관리
- 문제점
    - 데이터베이스에 저장하기 위해 필요한 것 ?
        - SQL이며, 무한 반복과 지루한 코드
    - 작업 도중 필드 추가가 된다면 ?
        - 모든 SQL문 수정 필요
    - SQL에 의존적인 개발
    
- 패러다임의 불일치
    - 객체, RDB 패러다임의 불일치 ?
        - 이론적 틀이나 개념의 집합체
        - 객체와 RDB는 비슷하면서도 다름
    - 패러다임의 종류 ?
        - 상속
        - 연관관계
        - 데이터 타입
        - 데이터 식별 방법
    - 상속
        - 객체는 상속 개념이 있으나, RDB는 없음
        - 저장 : 객체를 분해 후 부모, 자식 테이블에 각각 데이터 저장
            - 예) Item, Album
        - 조회 : 각 테이블에 따른 조인 SQL 작성 + 각각 객체 생성 + …
        - **자바 컬렉션을 사용한다면 add, get 대체 가능 !**
    - 연관관계
        - 객체는 참조를 사용하고, RDB는 외래 키 사용
        - 모델링 1 : 객체 → 테이블
            - Insert 편리, 객체 형태 모델링 X
            - 예) Member의 Team을 id로 저장
        - 모델링 2 : 객체 → 객체
            - Insert 불편, 객체 형태 모델링 O
            - 예) Member의 Team을 객체로 저장
        - **Insert가 불편하지만, 자바 컬렉션을 사용한다면 add, get 대체 가능 !**
- 객체 그래프 탐색
    - 객체는 자유롭게 객체 그래프 탐색이 가능해야 하지만 불가
        - 첫 실행 SQL에 따라 탐색 범위 결정
        - 엔티티에 대한 신뢰성 문제 발생 (메서드 호출에 대한 성공 여부 확신 X)
        - 모든 객체 미리 로딩은 성능 저하
    - 물리적으로 분리되었으나, 논리적으로 엮여 진정한 계층 분할이 어려움
- 객체 비교
    - 일반적인 getMember( )
        - getMember( ) == getMember( ) → false
        - getMember 새로운 인스턴스를 생성
    - 자바 컬렉션 get( )
        - get( ) == get( ) → true
- 객체 모델링을 진행 할수록 작업이 많아짐
- 자바 컬렉션처럼 사용하기 위해 JPA 등장

## JPA

- JPA vs ORM
    - JPA - Java Persistence API
    - 자바 진영의 ORM 기술 표준
    
    ---
    
    - ORM - Object relation mapping
    - 각 특성에 맞게 설계 (객체는 객체, RDB는 RDB) 후 중간에서 매핑
- JPA 소개
    - EJB → Hibernate → JPA
    - 거의 Hibernate를 구현체로 사용하는 인터페이스의 모음
- JPA 동작
    - Entity 분석, SQL 생성, JDBC API 사용
    - 패러다임 불일치 해결
    - 생산성, 유지 보수, 성능, 표준
- JPA 생성성
    - 저장 : jpa.persist(Entity);
    - 조회 : jpa.find(Id);
    - 수정 : setName(String);
    - 삭제 : jpa.remove(Entity);
    - 트랜젝션 안에서 조회 후 변경하면 작업이 끝나는 시점에 업데이트 쿼리가 자동으로 날림
- JPA 유지 보수
    - 필드 변경, 추가 시 모든 SQL 수정 X
- JPA 패러다임 불일치
    - 상속, 연관관계, 객체 그래프 탐색, 비교하기 해결
- JPA의 성능 최적화
    - 1차 캐시와 동일성 보장
        - 동일 트랜젝션 안에서 한 번 가져온 데이터는 캐시되어 다음 조회 때 재사용
    - 쓰기 지연
        - 쿼리를 모았다가 커밋하는 동시에 모두 전달
    - 지연 로딩
        - 객체가 실제 사용될 때 로딩